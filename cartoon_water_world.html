<!DOCTYPE html> <!-- HTML5æ–‡æ¡£ç±»å‹å£°æ˜ - å‘Šè¯‰æµè§ˆå™¨è¿™æ˜¯ç°ä»£HTML -->
<html lang="zh-CN"> <!-- HTMLæ ¹å…ƒç´ å¼€å§‹ï¼Œlang="zh-CN"è®¾ç½®é¡µé¢è¯­è¨€ä¸ºç®€ä½“ä¸­æ–‡ -->

<head>
    <meta charset="UTF-8"> <!-- è®¾ç½®å­—ç¬¦ç¼–ç ä¸ºUTF-8ï¼Œæ”¯æŒä¸­æ–‡å’Œå„ç§ç‰¹æ®Šå­—ç¬¦ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0"> <!-- ç§»åŠ¨ç«¯é€‚é… - è®©é¡µé¢åœ¨æ‰‹æœºä¸Šæ­£å¸¸æ˜¾ç¤º -->
    <title>ğŸ¨ å¡é€šæ°´é¢ä¸–ç•Œ</title> <!-- æµè§ˆå™¨æ ‡ç­¾é¡µæ˜¾ç¤ºçš„æ ‡é¢˜ -->
    <!-- å¼•ç”¨æœ€æ–°ç‰ˆ three.js å’Œ OrbitControls -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.153.0/examples/js/utils/BufferGeometryUtils.min.js"></script>
    <!-- CSSæ ·å¼å¼€å§‹ - å®šä¹‰é¡µé¢çš„å¤–è§‚å’Œå¸ƒå±€ -->
    <style>
        /* =================== å…¨å±€é‡ç½®ï¼Œç¡®ä¿æ— ç¼éš™ =================== */
        html, body {
            margin: 0 !important; /* å»é™¤æµè§ˆå™¨é»˜è®¤å¤–è¾¹è· */
            padding: 0 !important; /* å»é™¤æµè§ˆå™¨é»˜è®¤å†…è¾¹è· */
            box-sizing: border-box; /* è®©æ‰€æœ‰å…ƒç´ çš„å®½é«˜åŒ…å«paddingå’Œborder */
            width: 100vw; /* è§†å£å®½åº¦ */
            height: 100vh; /* è§†å£é«˜åº¦ */
        }

        body {
            background: linear-gradient(135deg, #87a0c0 0%, #15263f 100%); /* é¡µé¢èƒŒæ™¯æ¸å˜è‰² */
            font-family: 'å¾®è½¯é›…é»‘', Arial, sans-serif; /* å…¨å±€å­—ä½“ */
            overflow: hidden; /* éšè—æ»šåŠ¨æ¡ï¼Œä¿è¯å…¨å±ä½“éªŒ */
        }

        #canvas {
            display: block; /* è®©canvasç‹¬å ä¸€è¡Œ */
            width: 100vw;   /* å…¨å±å®½åº¦ */
            height: 100vh;  /* å…¨å±é«˜åº¦ */
            /*cursor: grab;   /* é¼ æ ‡æ‚¬åœæ—¶æ˜¾ç¤ºæŠ“æ‰‹ */
        }
        #canvas:active { cursor: grabbing; }

        /* =================== è®¾ç½®é¢æ¿å¤–å±‚å®¹å™¨ =================== */
        .settings-panel {
            position: fixed;
            top: 0; /* é¡¶éƒ¨è´´è¾¹ */
            left: 0; /* å·¦ä¾§è´´è¾¹ */
            z-index: 1000;
            background: none;
            border: none;
            box-shadow: none;
            width: auto;
            height: auto;
            display: flex;
            flex-direction: column;
            align-items: center;
            pointer-events: auto;
        }
        /* =================== åœºæ™¯è®¾ç½®æŒ‰é’®ç‹¬ç«‹åŒ…å›´æ¡† =================== */
        .settings-panel-header {
            background: linear-gradient(180deg,#2935a588 0%,#28679e86 100%);
            border: 2px solid #7ea6e0;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.08);
            width: 240px; /* æŒ‰é’®å®½åº¦ */
            height: 56px; /* æŒ‰é’®é«˜åº¦ */
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0; /* å»é™¤å¤–è¾¹è·ï¼Œç´§è´´å·¦ä¸Šè§’ */
            transition: width 0.2s;
        }
        .settings-toggle-btn {
            width: 100%;
            height: 100%;
            background: none;
            border: none;
            color: #252e53;
            font-size: 20px;
            font-weight: bold;
            text-align: center;
            padding: 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            user-select: none;
        }
        /* =================== å±•å¼€æ—¶æŒ‰é’®åŒºå®½åº¦æ‰©å±• =================== */
        .settings-panel.expanded .settings-panel-header {
            width: 360px; /* ä¸å†…å®¹åŒºå®½åº¦ä¸€è‡´ */
            transition: width 0.2s;
        }
        /* =================== å†…å®¹åŒºç‹¬ç«‹åŒ…å›´æ¡† =================== */
        .settings-panel-content {
            max-height: 0;
            opacity: 0;
            pointer-events: none;
            transition: max-height 0.3s cubic-bezier(.4,0,.2,1), opacity 0.2s;
            overflow: hidden;
            margin-top: 8px;
            background: linear-gradient(180deg,#2935a588 0%,#28679e86 100%);
            border: 2px solid #7ea6e0;
            border-radius: 10px;
            box-shadow: 0 8px 24px rgba(0,0,0,0.08);
            width: 360px;
            height: 536px; /* 600-æŒ‰é’®é«˜åº¦-é—´éš” */
            box-sizing: border-box;
            overflow-y: auto; /* åªå…è®¸å†…å®¹åŒºæ»šåŠ¨ */
            overflow-x: hidden;
            /* éšè—æ»šåŠ¨æ¡ï¼Œå…¼å®¹ä¸»æµæµè§ˆå™¨ */
            scrollbar-width: none; /* Firefox */
            -ms-overflow-style: none; /* IE/Edge */
            padding: 16px;
        }
        .settings-panel-content::-webkit-scrollbar {
            display: none; /* Chrome/Safari/Webkit */
        }
        .settings-panel.expanded .settings-panel-content {
            max-height: 1000px; /* è¶³å¤Ÿå¤§å³å¯ */
            opacity: 1;
            pointer-events: auto;
        }
        /* =================== è§„èŒƒ label ç»“æ„å’Œè‡ªé€‚åº”å¸ƒå±€ =================== */
        .settings-panel label {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 15px;
            width: 100%;
            box-sizing: border-box;
        }
        .settings-panel .label-name {
            flex: 0 0 90px;      /* å›ºå®šå®½åº¦æˆ–æœ€å°å®½åº¦ */
            max-width: 120px;    /* é˜²æ­¢åå­—å¤ªé•¿æ’‘çˆ† */
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .settings-panel input[type="range"] {
            flex: 1 1 60%;
            min-width: 60px;
            max-width: 140px;
            margin: 0 10px;
        }
        .settings-panel .label-value {
            flex: 0 0 40px;
            max-width: 50px;
            text-align: right;
        }
        /* =================== è®¾ç½®é¢æ¿åˆ†ç»„ï¼ˆfieldsetï¼‰è‡ªé€‚åº”åŠåˆ†ç»„é£æ ¼ =================== */
        .settings-panel fieldset {
            margin: 0 0 18px 0; /* åªä¿ç•™ä¸‹é—´è·ï¼Œå·¦å³æ— é—´è· */
            padding: 12px 10px 10px 10px; /* åˆ†ç»„å†…è¾¹è· */
            border-radius: 8px;
            background: rgba(255,255,255,0.06);
            box-sizing: border-box;
            width: 100%; /* å…³é”®ï¼šåˆ†ç»„å®½åº¦è‡ªé€‚åº”å¤–æ¡† */
            max-width: none;
            border: 1.5px solid #8fc4f7; /* é»˜è®¤è¾¹æ¡†è‰²ï¼Œå¯è¢«ä¸‹æ–¹è¦†ç›– */
        }
        /* ====== åˆ†ç»„ï¼šå¤©ç©º ====== */
        .settings-panel .fieldset-sky {
            border-color: #8fc4f7; /* çº¿æ¡†é¢œè‰² */
        }
        .settings-panel .fieldset-sky legend {
            color: #3498db; /* æ ‡é¢˜é¢œè‰² */
        }
        .settings-panel .fieldset-sky label span {
            color: #3498db; /* UIåå­—é¢œè‰² */
        }
        /* ====== åˆ†ç»„ï¼šé˜³å…‰ ====== */
        .settings-panel .fieldset-sun {
            border-color: #f7c873;
        }
        .settings-panel .fieldset-sun legend {
            color: #f7c873;
        }
        .settings-panel .fieldset-sun label span {
            color: #f7c873;
        }
        /* ====== åˆ†ç»„ï¼šæ°´é¢ ====== */
        .settings-panel .fieldset-water {
            border-color: #4ecdc4;
        }
        .settings-panel .fieldset-water legend {
            color: #4ecdc4;
        }
        .settings-panel .fieldset-water label span {
            color: #4ecdc4;
        }
        /* ====== åˆ†ç»„ï¼šå…‰ç…§è°ƒèŠ‚ ====== */
        .settings-panel .fieldset-light {
            border-color: #1D2649;
        }
        .settings-panel .fieldset-light legend {
            color: #1D2649;
        }
        .settings-panel .fieldset-light label span {
            color: #1D2649;
        }
        .settings-panel legend {
            font-size: 15px; padding: 0 8px;
            font-weight: bold;
        }
        /* è®¾ç½®é¢æ¿å†…çš„labelã€æ»‘å—ã€åˆ†ç»„ç­‰æ ·å¼ */
        .settings-panel input[type="color"] { margin-right: 8px; }
        .settings-panel .slider-row {
            display: flex; align-items: center; margin-bottom: 8px;
        }
        .settings-panel .slider-row label { flex: 0 0 70px; margin: 0; }
        .settings-panel .slider-row input[type="range"] { flex: 1 1 60%; margin: 0 10px; }
        .settings-panel .slider-row span { flex: 0 0 40px; text-align: right; }
        .slider-label { font-weight: bold; color: #4ecdc4; margin-right: 8px; }
        .settings-panel fieldset,
        .settings-panel label,
        .settings-panel .slider-row {
            width: 100%; box-sizing: border-box;
        }
        .settings-panel input[type="range"] {
            width: 70%; min-width: 40px; max-width: 95%;
        }

        /* =================== åŠ è½½è¿›åº¦æ¡ç›¸å…³ =================== */
        .progress-container {
            position: fixed; /* å›ºå®šå±…ä¸­ */
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; z-index: 2000;
        }
        .progress-text {
            color: #ff7fff; /* åŠ è½½æ–‡å­—é¢œè‰²ï¼Œå¯è‡ªå®šä¹‰ */
            font-size: 24px; /* åŠ è½½æ–‡å­—å¤§å°ï¼Œå¯è‡ªå®šä¹‰ */
            font-weight: bold;
            margin-bottom: 20px;
            text-shadow: 2px 2px 4px rgba(54, 24, 40, 0.8); /* æ–‡å­—é˜´å½±ï¼Œå¯è‡ªå®šä¹‰ */
        }
        .progress-bar {
            width: 600px;  /* è¿›åº¦æ¡å®½åº¦ï¼Œå¯è‡ªå®šä¹‰ */
            height: 8px;   /* è¿›åº¦æ¡é«˜åº¦ï¼Œå¯è‡ªå®šä¹‰ */
            background: rgba(255, 255, 255, 0.5); /* è¿›åº¦æ¡åº•è‰² */
            border-radius: 6px; /* åœ†è§’ */
            overflow: hidden;
            border: 2px solid #fd79a8; /* è¾¹æ¡†é¢œè‰² */
            margin: 0 auto;
        }
        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #fd79a8, #fdcb6e); /* æ¸å˜è‰²ï¼Œå¯è‡ªå®šä¹‰ */
            width: 0%; /* ç”±JSåŠ¨æ€æ§åˆ¶ */
            transition: width 0.5s ease; /* å¹³æ»‘åŠ¨ç”» */
            border-radius: 4px;
        }

        /* =================== å“åº”å¼é€‚é…ï¼ˆæ‰‹æœºç«¯ï¼‰ =================== */
        @media (max-width: 600px) {
            .settings-panel {
                width: 98vw; max-width: none; min-width: 0; left: 0; top: 0;
                font-size: 13px; padding: 6px;
            }
            .progress-bar { width: 90vw; }
        }
        @media (max-width: 900px) and (orientation: landscape) {
            .settings-panel {
                width: 60vw; max-width: none; min-width: 0; left: 0; top: 0;
                font-size: 12px; padding: 4px;
            }
            .progress-bar { width: 60vw; }
        }
    </style>
</head>

<body>
    <!-- =================== è®¾ç½®é¢æ¿ =================== -->
    <div class="settings-panel" id="settingsPanel">
        <!-- =================== é¡¶éƒ¨æŒ‰é’®åŒºï¼ˆå§‹ç»ˆæœ‰ç‹¬ç«‹åŒ…å›´æ¡†ï¼‰ =================== -->
        <div class="settings-panel-header">
            <button id="toggleSettingsPanel" class="settings-toggle-btn">
                <span style="font-size:22px;">âš™ï¸</span> åœºæ™¯è®¾ç½®
            </button>
        </div>
        <!-- =================== å¯æŠ˜å çš„è®¾ç½®å†…å®¹åŒºï¼ˆç‹¬ç«‹åŒ…å›´æ¡†ï¼‰ =================== -->
        <div class="settings-panel-content" id="settingsPanelContent">
            <!-- ===== å¤©ç©ºé¢œè‰²åˆ†ç»„ ===== -->
            <fieldset class="fieldset-sky">
                <legend>ğŸŒŒ <å¤© ç©º></legend>
                <div style="display: flex; justify-content: center; align-items: center; gap: 24px;">
                    <input type="color" id="middleColorPicker" value="#3789E1"
                        style="width:36px;height:36px;border:none;background:none;cursor:pointer;">
                    <input type="color" id="bottomColorPicker" value="#ABDEF7"
                        style="width:36px;height:36px;border:none;background:none;cursor:pointer;">
                </div>
            </fieldset>
            <!-- ===== é˜³å…‰é¢œè‰²è®¾ç½® ===== -->
            <fieldset class="fieldset-sun">
                <legend>â˜€ï¸ <é˜³ å…‰></legend>
                <div style="display: flex; justify-content: center; align-items: center; gap: 24px;">
                    <input type="color" id="sunColorPicker" value="#FFE4B5"
                        style="vertical-align:middle;width:36px;height:36px;border:none;background:none;cursor:pointer;">
                </div>
                <div style="margin-top:10px;">
                    <label>
                        <span class="label-name">æ–¹ å‘ X</span>
                        <input type="range" id="sunDirXSlider" min="-90" max="90" step="1" value="45"
                            style="vertical-align:middle;width:120px;">
                        <span class="label-value" id="sunDirXValue">45</span>Â°
                    </label>
                </div>
                <div style="margin-top:6px;">
                    <label>
                        <span class="label-name">æ–¹ å‘ Y</span>
                        <input type="range" id="sunDirZSlider" min="-180" max="180" step="1" value="180"
                            style="vertical-align:middle;width:120px;">
                        <span class="label-value" id="sunDirZValue">45</span>Â°
                    </label>
                </div>
            </fieldset>
            <!-- ===== æ°´é¢æ³•çº¿è´´å›¾å‚æ•°åˆ†ç»„ ===== -->
            <fieldset class="fieldset-water">
                <legend>ğŸŒŠ <æ°´ é¢></legend>
                <div style="margin-bottom:10px;">
                    <label>
                        <span class="label-name">çº¹ç†ç¼©æ”¾</span>
                        <input type="range" id="waterRepeatSlider" min="1" max="100" step="0.1" value="50"
                            style="vertical-align:middle;width:120px;">
                        <span class="label-value" id="waterRepeatValue">3.00</span>
                    </label>
                </div>
                <div>
                    <label>
                        <span class="label-name">çº¹ç†å¼ºåº¦</span>
                        <input type="range" id="waterNormalStrengthSlider" min="0" max="1" step="0.01" value="0.2"
                            style="vertical-align:middle;width:120px;">
                        <span class="label-value" id="waterNormalStrengthValue">0.20</span>
                    </label>
                </div>
                <div>
                    <label>
                        <span class="label-name">æ°´æµé€Ÿåº¦</span>
                        <input type="range" id="waterSpeedSlider" min="0.01" max="1" step="0.001" value="0.06"
                            style="vertical-align:middle;width:120px;">
                        <span class="label-value" id="waterSpeedValue">0.06</span>
                    </label>
                </div>
                <div style="margin-top:10px;">
                    <label>
                        <span class="label-name">é«˜å…‰èŒƒå›´</span><input
                            id="waterSpecularThresholdSlider" type="range" min="0" max="1.0" step="0.01" value="0.1"><span
                            class="label-value" id="waterSpecularThresholdValue">0.1</span>
                    </label>
                </div>
                <div>
                    <label>
                        <span class="label-name">é«˜å…‰å¼ºåº¦</span><input
                            id="waterSpecularStrengthSlider" type="range" min="0.0" max="1.0" step="0.01" value="0.5"><span
                            class="label-value" id="waterSpecularStrengthValue">0.5</span>
                    </label>
                </div>
                <div>
                    <label>
                        <span class="label-name">è²å°¼å°”èŒƒå›´</span><input
                            id="waterFresnelPowerSlider" type="range" min="1.0" max="5.0" step="0.01" value="3.0"><span
                            class="label-value" id="waterFresnelPowerValue">2.5</span></label>
                </div>
                <div>
                    <label>
                        <span class="label-name">è²å°¼å°”å¼ºåº¦</span><input
                            id="waterFresnelStrengthSlider" type="range" min="0.0" max="1.0" step="0.01" value="0.18"><span
                            class="label-value" id="waterFresnelStrengthValue">0.4</span></label>
                </div>
            </fieldset>
            <!-- ===== å…‰ç…§è°ƒèŠ‚åˆ†ç»„ï¼ˆé˜´å½±+æ˜æš—ï¼‰ ===== -->
            <fieldset class="fieldset-light">
                <legend>ğŸ’¡ å…‰ç…§è°ƒèŠ‚</legend>
                <div style="margin-bottom:10px;">
                    <label>
                        <span class="label-name">é˜´ å½±</span>
                        <input type="range" id="shadowSlider" min="0" max="1" step="0.01" value="0.6"
                            style="vertical-align:middle;width:120px;">
                        <span class="label-value" id="shadowValue">0.60</span>
                    </label>
                </div>
                <div>
                    <label>
                        <span class="label-name">æ˜ æš—</span>
                        <input type="range" id="brightnessSlider" min="0.01" max="1" step="0.01" value="0.7"
                            style="vertical-align:middle;width:120px;">
                        <span class="label-value" id="brightnessValue">0.70</span>
                    </label>
                </div>
            </fieldset>
        </div>
    </div>

    <!-- åŠ è½½è¿›åº¦ -->
    <div class="progress-container" id="progressContainer">
        <div class="progress-text" id="progressText">ğŸŒˆ æ­£åœ¨åˆ›å»ºå¡é€šä¸–ç•Œ...</div>
        <div class="progress-bar">
            <div class="progress-fill" id="progressFill"></div>
        </div>
    </div>

    <!-- WebGLç”»å¸ƒ -->
    <canvas id="canvas"></canvas>

    <!-- JavaScriptå¼€å§‹ - è¿™é‡Œæ˜¯WebGLçš„æ ¸å¿ƒé€»è¾‘ -->
    <script>
        /**
         * ========== å·¥å…·å‡½æ•°åŒº ==========
         * ç”¨äºåŠ è½½shaderç­‰é€šç”¨æ“ä½œ
         */
        async function loadShader(url) {
            const response = await fetch(url);
            if (!response.ok) throw new Error('æ— æ³•åŠ è½½shader: ' + url);
            const text = await response.text();
            if (!text) throw new Error('shaderå†…å®¹ä¸ºç©º: ' + url);
            return text;
        }

        /**
         * ========== å…¨å±€å˜é‡åŒº ==========
         * è¿™äº›å˜é‡è´¯ç©¿æ•´ä¸ªWebGLåœºæ™¯çš„ç”Ÿå‘½å‘¨æœŸ
         */
        let scene, camera, renderer, controls, waterMesh, testObjects = {};
        let mainLight, skyMaterial;
        let halfLambertMaterials = [];
        let globalBrightness = 0.7, globalShadow = 0.6;

        // è¿›åº¦æ¡ç›¸å…³DOM
        const progressFill = document.getElementById('progressFill');
        const progressText = document.getElementById('progressText');
        const progressContainer = document.getElementById('progressContainer');

        /**
         * ========== è¿›åº¦æ¡åŠŸèƒ½ ==========
         * ç”¨äºå±•ç¤ºåŠ è½½/åˆå§‹åŒ–è¿›åº¦
         */
        function updateProgress(percent, text) {
            progressFill.style.width = percent + '%';
            progressText.textContent = text;
            if (percent >= 100) {
                setTimeout(() => {
                    progressContainer.style.opacity = '0';
                    setTimeout(() => { progressContainer.style.display = 'none'; }, 500);
                }, 1000);
            }
        }

        /**
         * ========== é€šç”¨äº‹ä»¶ç»‘å®šå‡½æ•° ==========
         * å°è£…æ»‘æ†ã€é¢œè‰²é€‰æ‹©å™¨ç­‰é‡å¤é€»è¾‘ï¼Œå‡å°‘å†—ä½™
         */
        // æ»‘æ†æ•°å€¼æ˜¾ç¤ºå’ŒshaderåŒæ­¥
        function bindSlider(sliderId, valueId, uniformName = null, digits = 2) {
            const slider = document.getElementById(sliderId);
            const value = document.getElementById(valueId);
            function update(val) {
                value.textContent = parseFloat(val).toFixed(digits);
                if (uniformName && waterMesh && waterMesh.material && waterMesh.material.uniforms[uniformName]) {
                    waterMesh.material.uniforms[uniformName].value = parseFloat(val);
                }
            }
            slider.addEventListener('input', e => update(e.target.value));
            update(slider.value);
        }
        // é¢œè‰²é€‰æ‹©å™¨äº‹ä»¶ç»‘å®š
        function bindColorPicker(pickerId, onChange) {
            const picker = document.getElementById(pickerId);
            picker.addEventListener('input', e => onChange(e.target.value));
        }
        // ä¸»å…‰æ–¹å‘æ»‘æ†ç»‘å®š
        function bindSunDirectionSliders() {
            const xSlider = document.getElementById('sunDirXSlider');
            const zSlider = document.getElementById('sunDirZSlider');
            xSlider.addEventListener('input', updateMainLightDirection);
            zSlider.addEventListener('input', updateMainLightDirection);
            updateMainLightDirection();
        }

        /**
         * ========== ä¸»åˆå§‹åŒ–æµç¨‹ ==========
         * ä¾æ¬¡åˆå§‹åŒ–æ¸²æŸ“å™¨ã€å¤©ç©ºã€å…‰ç…§ã€æ°´é¢ã€ç‰©ä½“ã€åŠ¨ç”»å¾ªç¯
         */
        async function initCartoonWorld() {
            try {
                updateProgress(20, 'ğŸ”§ åˆå§‹åŒ–WebGLæ¸²æŸ“å™¨...');
                await initWebGLRenderer();
                updateProgress(40, 'ğŸŒˆ åˆ›å»ºå¡é€šå¤©ç©º...');
                await createCartoonSkybox();
                updateProgress(60, 'ğŸ’¡ è®¾ç½®å¡é€šå…‰ç…§...');
                setupCartoonLighting();
                updateProgress(80, 'ğŸŒŠ åˆ›å»ºå¡é€šæ°´é¢...');
                await createCartoonWater();
                updateProgress(90, 'ğŸª æ·»åŠ æµ‹è¯•ç‰©ä½“...');
                await createTestObjects();
                updateProgress(95, 'ğŸ¬ å¯åŠ¨åŠ¨ç”»å¾ªç¯...');
                startRenderLoop();
                updateProgress(100, 'âœ¨ å¡é€šä¸–ç•Œåˆ›å»ºå®Œæˆï¼');
            } catch (error) {
                console.error('âŒ åˆå§‹åŒ–å¤±è´¥:', error);
                updateProgress(0, 'âŒ åˆ›å»ºå¤±è´¥ï¼Œè¯·æ£€æŸ¥æ§åˆ¶å°');
            }
        }

        // 5. WebGLæ¸²æŸ“å™¨åˆå§‹åŒ–
        async function initWebGLRenderer() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 20, 30);
            camera.lookAt(0, 0, 0);
            const canvas = document.getElementById('canvas');
            renderer = new THREE.WebGLRenderer({
                canvas: canvas,
                antialias: true,
                alpha: true,
                powerPreference: "high-performance"
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputColorSpace = THREE.SRGBColorSpace;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1;
            setupOrbitControls();
        }

        function setupOrbitControls() {
            const script = document.createElement('script');
            script.src = 'https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js';
            script.onload = () => {
                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.dampingFactor = 0.25;
                controls.minDistance = 5;
                controls.maxDistance = 100;
                controls.maxPolarAngle = Math.PI / 2.1;
                controls.mouseButtons = {
                    LEFT: THREE.MOUSE.ROTATE,
                    MIDDLE: THREE.MOUSE.PAN,
                    RIGHT: undefined
                };
            };
            document.head.appendChild(script);
        }

        // 6. å¤©ç©ºç›’åˆ›å»º
        async function createCartoonSkybox() {
            const skyGeometry = new THREE.SphereGeometry(500, 32, 32);
            const vertexShader = await loadShader('shaders/sky.vert');
            const fragmentShader = await loadShader('shaders/sky.frag');
            skyMaterial = new THREE.ShaderMaterial({
                vertexShader, fragmentShader,
                uniforms: {
                    topColor: { value: new THREE.Color("#2741A5") },
                    middleColor: { value: new THREE.Color("#3789E1") },
                    bottomColor: { value: new THREE.Color("#ABDEF7") },
                    offset: { value: 33 },
                    exponent: { value: 0.6 },
                    brightness: { value: parseFloat(document.getElementById('brightnessSlider').value) }
                },
                side: THREE.BackSide
            });
            const sky = new THREE.Mesh(skyGeometry, skyMaterial);
            scene.add(sky);
        }

        // 7. ä¸»å…‰ç…§è®¾ç½®
        function setupCartoonLighting() {
            const sunColor = document.getElementById('sunColorPicker').value;
            globalBrightness = parseFloat(document.getElementById('brightnessSlider').value);
            mainLight = new THREE.DirectionalLight(sunColor, globalBrightness);
            // æ–¹å‘ç”±æ»‘æ†æ§åˆ¶
            updateMainLightDirection();
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 4096;
            mainLight.shadow.mapSize.height = 4096;
            mainLight.shadow.camera.near = 0.5;
            mainLight.shadow.camera.far = 500;
            mainLight.shadow.camera.left = -100;
            mainLight.shadow.camera.right = 100;
            mainLight.shadow.camera.top = 100;
            mainLight.shadow.camera.bottom = -100;
            mainLight.shadow.bias = 0;
            mainLight.shadow.normalBias = -0.04;
            scene.add(mainLight);
        }

        // 8. åˆ›å»ºå¡é€šæ°´é¢
        async function createCartoonWater() {
            const waterGeometry = new THREE.PlaneGeometry(400, 400, 2, 2);  //å®½é«˜ + åˆ†æ®µæ•°
            waterGeometry.computeTangents();
            const waterVertex = await loadShader('shaders/cartoonWater.vert');
            const waterFragment = await loadShader('shaders/cartoonWater.frag');
            const lightDir = mainLight ? mainLight.position.clone().normalize() : new THREE.Vector3(1, 2, 1).normalize();
            const lightColor = mainLight ? mainLight.color.clone() : new THREE.Color(document.getElementById('sunColorPicker').value);
            const ambientColor = new THREE.Color(document.getElementById('bottomColorPicker').value);
            const baseColor = new THREE.Color(0x4ECDC4);
            const normalMap = new THREE.TextureLoader().load('textures/waterNormal.png');
            normalMap.wrapS = normalMap.wrapT = THREE.RepeatWrapping;
            waterMesh = new THREE.Mesh(waterGeometry, new THREE.ShaderMaterial({
                uniforms: {
                    lightDirection: { value: lightDir.clone() },
                    lightColor: { value: lightColor.clone() },
                    ambientColor: { value: ambientColor.clone() },
                    baseColor: { value: baseColor.clone() },
                    brightness: { value: globalBrightness },
                    shadow: { value: globalShadow },
                    cameraPosition: { value: camera.position.clone() },
                    normalMap: { value: normalMap },
                    time: { value: 0.0 },
                    repeat: { value: parseFloat(document.getElementById('waterRepeatSlider').value) },
                    speed: { value: parseFloat(document.getElementById('waterSpeedSlider').value) },
                    specularThreshold: { value: parseFloat(document.getElementById('waterSpecularThresholdSlider').value) },
                    specularStrength: { value: parseFloat(document.getElementById('waterSpecularStrengthSlider').value) },
                    fresnelPower: { value: parseFloat(document.getElementById('waterFresnelPowerSlider').value) },
                    fresnelStrength: { value: parseFloat(document.getElementById('waterFresnelStrengthSlider').value) },
                    waterNormalStrength: { value: parseFloat(document.getElementById('waterNormalStrengthSlider').value) },
                    waveCenters: { value: Array(MAX_WAVES).fill(new THREE.Vector2(0, 0)) },
                    waveStartTimes: { value: Array(MAX_WAVES).fill(-10) },
                    waveCount: { value: 0 }
                },
                vertexShader: waterVertex,
                fragmentShader: waterFragment,
                transparent: false,
                side: THREE.DoubleSide
            }));

            // æ·»åŠ æ¶Ÿæ¼ªæ³•çº¿è´´å›¾
            const ringNormalMap = new THREE.TextureLoader().load('textures/rippleNormal.png');
            ringNormalMap.wrapS = ringNormalMap.wrapT = THREE.ClampToEdgeWrapping;

            waterMesh = new THREE.Mesh(waterGeometry, new THREE.ShaderMaterial({
                uniforms: {
                    lightDirection: { value: lightDir.clone() },
                    lightColor: { value: lightColor.clone() },
                    ambientColor: { value: ambientColor.clone() },
                    baseColor: { value: baseColor.clone() },
                    brightness: { value: globalBrightness },
                    shadow: { value: globalShadow },
                    cameraPosition: { value: camera.position.clone() },
                    normalMap: { value: normalMap },
                    ringNormalMap: { value: ringNormalMap }, // æ–°å¢
                    time: { value: 0.0 },
                    repeat: { value: parseFloat(document.getElementById('waterRepeatSlider').value) },
                    speed: { value: parseFloat(document.getElementById('waterSpeedSlider').value) },
                    specularThreshold: { value: parseFloat(document.getElementById('waterSpecularThresholdSlider').value) },
                    specularStrength: { value: parseFloat(document.getElementById('waterSpecularStrengthSlider').value) },
                    fresnelPower: { value: parseFloat(document.getElementById('waterFresnelPowerSlider').value) },
                    fresnelStrength: { value: parseFloat(document.getElementById('waterFresnelStrengthSlider').value) },
                    waterNormalStrength: { value: parseFloat(document.getElementById('waterNormalStrengthSlider').value) },
                    waveCenters: { value: Array(MAX_WAVES).fill(new THREE.Vector2(0, 0)) },
                    waveStartTimes: { value: Array(MAX_WAVES).fill(-10) },
                    waveCount: { value: 0 }
                },
                vertexShader: waterVertex,
                fragmentShader: waterFragment,
                transparent: false,
                side: THREE.DoubleSide
            }));
            waterMesh.rotation.x = -Math.PI / 2;
            waterMesh.position.y = 0;
            waterMesh.receiveShadow = true;
            scene.add(waterMesh);
        }

        // 9. åˆ›å»ºæµ‹è¯•ç‰©ä½“ï¼ˆå¡é€šé£æ ¼ï¼‰
        async function createTestObjects() {
            const halfLambertVertex = await loadShader('shaders/halfLambert.vert');
            const halfLambertFragment = await loadShader('shaders/halfLambert.frag');
            const lightDir = mainLight ? mainLight.position.clone().normalize() : new THREE.Vector3(1, 2, 1).normalize();
            const lightColor = mainLight ? mainLight.color.clone() : new THREE.Color(document.getElementById('sunColorPicker').value);
            const ambientColor = new THREE.Color(document.getElementById('bottomColorPicker').value);
            function createHalfLambertMaterial(color) {
                const mat = new THREE.ShaderMaterial({
                    uniforms: {
                        lightDirection: { value: lightDir.clone() },
                        lightColor: { value: lightColor.clone() },
                        ambientColor: { value: ambientColor.clone() },
                        baseColor: { value: new THREE.Color(color) },
                        brightness: { value: globalBrightness },
                        shadow: { value: globalShadow },
                    },
                    vertexShader: halfLambertVertex,
                    fragmentShader: halfLambertFragment
                });
                halfLambertMaterials.push(mat);
                return mat;
            }
            // ç«‹æ–¹ä½“
            const cubeGeometry = new THREE.BoxGeometry(4, 4, 4);
            const cubeMaterial = createHalfLambertMaterial(0xFF6B9D);
            const cube = new THREE.Mesh(cubeGeometry, cubeMaterial);
            cube.position.set(-10, 0, 0);
            cube.castShadow = true;
            cube.receiveShadow = true;
            scene.add(cube);
            testObjects.cube = cube;
            // çƒä½“
            const sphereGeometry = new THREE.SphereGeometry(3, 32, 32);
            const sphereMaterial = createHalfLambertMaterial(0xFFE135);
            const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
            sphere.position.set(10, 0, 0);
            sphere.castShadow = true;
            sphere.receiveShadow = true;
            scene.add(sphere);
            testObjects.sphere = sphere;
            // åœ†é”¥
            const coneGeometry = new THREE.ConeGeometry(3, 6, 8);
            const coneMaterial = createHalfLambertMaterial(0x95E1D3);
            const cone = new THREE.Mesh(coneGeometry, coneMaterial);
            cone.position.set(0, 0, -15);
            cone.castShadow = true;
            cone.receiveShadow = true;
            scene.add(cone);
            testObjects.cone = cone;
        }

        // 10. æ¸²æŸ“å¾ªç¯
        function startRenderLoop() {
            const startTime = Date.now();
            function animate() {
                requestAnimationFrame(animate);
                const elapsedTime = (Date.now() - startTime) / 1000;
                updateAnimations(elapsedTime);
                if (controls) controls.update();
                updateWaterCameraUniform();
                if (waterMesh && waterMesh.material && waterMesh.material.uniforms.time) {
                    waterMesh.material.uniforms.time.value = performance.now() * 0.001;
                }
                renderer.render(scene, camera);
            }
            animate();
        }

        // 11. åŠ¨ç”»æ›´æ–°ï¼ˆç‰©ä½“åŠ¨ç”»ï¼‰
        function updateAnimations(time) {
            if (testObjects.cube) {
                testObjects.cube.rotation.y = time * 0.2;
                testObjects.cube.rotation.x = Math.sin(time) * 0.2;
            }
            if (testObjects.sphere) {
                testObjects.sphere.position.y = Math.sin(time * 2) * 0.4 + 0.2;
                testObjects.sphere.rotation.z = time * 0.3;
            }
            if (testObjects.cone) {
                testObjects.cone.rotation.z = Math.sin(time * 1.5) * 0.15;
                testObjects.cone.position.y = Math.cos(time * 0.8) * 0.3 + 1;
            }
        }

        // 12. å“åº”å¼å¤„ç†
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        /**
         * ========== é¡µé¢åŠ è½½å¯åŠ¨ ==========
         * é¡µé¢åŠ è½½åå»¶è¿Ÿå¯åŠ¨ä¸»æµç¨‹ï¼Œå¹¶æ‰¹é‡ç»‘å®šæ‰€æœ‰æ»‘æ†å’Œé¢œè‰²æ§ä»¶
         */
        window.addEventListener('load', async () => {
            // æ‰¹é‡ç»‘å®šæ»‘æ†å’Œé¢œè‰²æ§ä»¶
            bindSlider('waterRepeatSlider', 'waterRepeatValue', 'repeat');
            bindSlider('waterSpeedSlider', 'waterSpeedValue', 'speed');
            bindSlider('waterSpecularThresholdSlider', 'waterSpecularThresholdValue', 'specularThreshold');
            bindSlider('waterSpecularStrengthSlider', 'waterSpecularStrengthValue', 'specularStrength');
            bindSlider('waterFresnelPowerSlider', 'waterFresnelPowerValue', 'fresnelPower');
            bindSlider('waterFresnelStrengthSlider', 'waterFresnelStrengthValue', 'fresnelStrength');
            bindSlider('waterNormalStrengthSlider', 'waterNormalStrengthValue', 'waterNormalStrength');
            bindSlider('shadowSlider', 'shadowValue');
            bindSlider('brightnessSlider', 'brightnessValue');
            bindColorPicker('bottomColorPicker', val => {
                if (skyMaterial) skyMaterial.uniforms.bottomColor.value.set(val);
                const ambColor = new THREE.Color(val);
                halfLambertMaterials.forEach(mat => {
                    if (mat.uniforms.ambientColor) mat.uniforms.ambientColor.value.copy(ambColor);
                });
                updateWaterUniforms();
            });
            bindColorPicker('middleColorPicker', val => {
                if (skyMaterial) skyMaterial.uniforms.middleColor.value.set(val);
            });
            bindColorPicker('sunColorPicker', val => {
                if (mainLight) mainLight.color.set(val);
                const sunColor = new THREE.Color(val);
                halfLambertMaterials.forEach(mat => {
                    if (mat.uniforms.lightColor) mat.uniforms.lightColor.value.copy(sunColor);
                });
                updateWaterUniforms();
            });
            document.getElementById('brightnessSlider').addEventListener('input', e => {
                globalBrightness = parseFloat(e.target.value);
                if (mainLight) mainLight.intensity = 1.5 * globalBrightness;
                if (skyMaterial) skyMaterial.uniforms.brightness.value = globalBrightness;
                halfLambertMaterials.forEach(mat => {
                    if (mat.uniforms.brightness) mat.uniforms.brightness.value = globalBrightness;
                });
                updateWaterUniforms();
            });
            document.getElementById('shadowSlider').addEventListener('input', e => {
                globalShadow = parseFloat(e.target.value);
                halfLambertMaterials.forEach(mat => {
                    if (mat.uniforms.shadow) mat.uniforms.shadow.value = globalShadow;
                });
                updateWaterUniforms();
            });
            bindSunDirectionSliders();
            await new Promise(resolve => setTimeout(resolve, 500));
            await initCartoonWorld();
        });

        // 14. é¢œè‰²å’Œæ˜æš—è°ƒèŠ‚äº‹ä»¶ç›‘å¬
        // ç›‘å¬å¤©ç©ºåº•éƒ¨é¢œè‰²ï¼Œå®æ—¶æ›´æ–°ç¯å¢ƒå…‰é¢œè‰²
        document.getElementById('bottomColorPicker').addEventListener('input', e => {
            if (skyMaterial) skyMaterial.uniforms.bottomColor.value.set(e.target.value);
            // åŒæ­¥æ‰€æœ‰halfLambertæè´¨çš„ç¯å¢ƒå…‰é¢œè‰²
            const ambColor = new THREE.Color(e.target.value);
            halfLambertMaterials.forEach(mat => {
                if (mat.uniforms.ambientColor) mat.uniforms.ambientColor.value.copy(ambColor);
            });
            updateWaterUniforms();
        });

        // é˜³å…‰é¢œè‰²æ‹¾è‰²å™¨ï¼Œå®æ—¶æ›´æ–° mainLight é¢œè‰²å’Œæ‰€æœ‰halfLambertæè´¨çš„ä¸»å…‰é¢œè‰²
        document.getElementById('sunColorPicker').addEventListener('input', e => {
            if (mainLight) mainLight.color.set(e.target.value);
            // åŒæ­¥æ‰€æœ‰halfLambertæè´¨çš„ä¸»å…‰é¢œè‰²
            const sunColor = new THREE.Color(e.target.value);
            halfLambertMaterials.forEach(mat => {
                if (mat.uniforms.lightColor) mat.uniforms.lightColor.value.copy(sunColor);
            });
            updateWaterUniforms();
        });

        // æ˜æš—æ»‘æ†ï¼Œå®æ—¶æ›´æ–° mainLight å¼ºåº¦å’Œæ‰€æœ‰halfLambertæè´¨æ˜æš—
        document.getElementById('brightnessSlider').addEventListener('input', e => {
            globalBrightness = parseFloat(e.target.value);
            if (mainLight) mainLight.intensity = 1.5 * globalBrightness;
            if (skyMaterial) skyMaterial.uniforms.brightness.value = globalBrightness;
            halfLambertMaterials.forEach(mat => {
                if (mat.uniforms.brightness) mat.uniforms.brightness.value = globalBrightness;
            });
            updateWaterUniforms();
        });

        // é˜´å½±æ»‘æ†ï¼Œå®æ—¶æ›´æ–°æ‰€æœ‰halfLambertæè´¨çš„æš—éƒ¨uniform
        document.getElementById('shadowSlider').addEventListener('input', e => {
            globalShadow = parseFloat(e.target.value);
            halfLambertMaterials.forEach(mat => {
                if (mat.uniforms.shadow) mat.uniforms.shadow.value = globalShadow;
            });
            updateWaterUniforms();
        });

        // ç›‘å¬å¤©ç©ºä¸­é—´é¢œè‰²ï¼Œå®æ—¶æ›´æ–°å¤©ç©ºçƒçš„ä¸­é—´è‰²
        document.getElementById('middleColorPicker').addEventListener('input', e => {
            if (skyMaterial) skyMaterial.uniforms.middleColor.value.set(e.target.value);
        });

        // æ°´é¢shaderè”åŠ¨ï¼šä¸»å…‰ã€ç¯å¢ƒå…‰ã€æ˜æš—ã€é˜´å½±ã€ç›¸æœºå‚æ•°
        function updateWaterUniforms() {
            if (!waterMesh || !waterMesh.material || !waterMesh.material.uniforms) return;
            // ä¸»å…‰
            if (mainLight && waterMesh.material.uniforms.lightDirection)
                waterMesh.material.uniforms.lightDirection.value.copy(mainLight.position.clone().normalize());
            if (mainLight && waterMesh.material.uniforms.lightColor)
                waterMesh.material.uniforms.lightColor.value.copy(mainLight.color);
            // ç¯å¢ƒå…‰
            if (waterMesh.material.uniforms.ambientColor)
                waterMesh.material.uniforms.ambientColor.value.set(document.getElementById('bottomColorPicker').value);
            // æ˜æš—
            if (waterMesh.material.uniforms.brightness)
                waterMesh.material.uniforms.brightness.value = globalBrightness;
            // é˜´å½±
            if (waterMesh.material.uniforms.shadow)
                waterMesh.material.uniforms.shadow.value = globalShadow;
            // ç›¸æœºä½ç½®
            if (waterMesh.material.uniforms.cameraPosition)
                waterMesh.material.uniforms.cameraPosition.value.copy(camera.position);

            // åŒæ­¥æ‰€æœ‰halfLambertæè´¨çš„ä¸»å…‰æ–¹å‘å’Œä¸»å…‰é¢œè‰²
            if (mainLight) {
                const dir = mainLight.position.clone().normalize();
                const color = mainLight.color;
                halfLambertMaterials.forEach(mat => {
                    if (mat.uniforms.lightDirection) mat.uniforms.lightDirection.value.copy(dir);
                    if (mat.uniforms.lightColor) mat.uniforms.lightColor.value.copy(color);
                    if (mat.uniforms.ambientColor) mat.uniforms.ambientColor.value.set(document.getElementById('bottomColorPicker').value);
                    if (mat.uniforms.brightness) mat.uniforms.brightness.value = globalBrightness;
                    if (mat.uniforms.shadow) mat.uniforms.shadow.value = globalShadow;
                });
            }
        }

        // æ¯å¸§æ›´æ–°æ°´é¢shaderçš„ç›¸æœºä½ç½®ï¼ˆä¿è¯è²æ¶…å°”/åå°„æ­£ç¡®ï¼‰
        function updateWaterCameraUniform() {
            if (waterMesh && waterMesh.material && waterMesh.material.uniforms && waterMesh.material.uniforms.cameraPosition) {
                waterMesh.material.uniforms.cameraPosition.value.copy(camera.position);
            }
        }

        // ç›‘å¬çº¹ç†ç¼©æ”¾æ»‘æ†ï¼Œå®æ—¶åŒæ­¥ repeat
        document.getElementById('waterRepeatSlider').addEventListener('input', e => {
            if (waterMesh && waterMesh.material && waterMesh.material.uniforms.repeat)
                waterMesh.material.uniforms.repeat.value = parseFloat(e.target.value);
        });

        // ç›‘å¬é€Ÿåº¦æ»‘æ†ï¼Œå®æ—¶åŒæ­¥ speed
        document.getElementById('waterSpeedSlider').addEventListener('input', e => {
            if (waterMesh && waterMesh.material && waterMesh.material.uniforms.speed)
                waterMesh.material.uniforms.speed.value = parseFloat(e.target.value);
        });

        // ====== å…¨å±€æ»‘æ†UIæ˜¾ç¤ºå’Œä¸»å…‰æ–¹å‘å‡½æ•° ======
        function updateMainLightDirection() {
            const sunDirXSlider = document.getElementById('sunDirXSlider');
            const sunDirZSlider = document.getElementById('sunDirZSlider');
            const sunDirXValue = document.getElementById('sunDirXValue');
            const sunDirZValue = document.getElementById('sunDirZValue');
            const xDeg = parseFloat(sunDirXSlider.value);
            const zDeg = parseFloat(sunDirZSlider.value);
            sunDirXValue.textContent = xDeg.toFixed(2);
            sunDirZValue.textContent = zDeg.toFixed(2);
            const xRad = xDeg * Math.PI / 180;
            const zRad = zDeg * Math.PI / 180;
            const y = Math.sin(xRad);
            const x = Math.cos(xRad) * Math.sin(zRad);
            const z = Math.cos(xRad) * Math.cos(zRad);
            if (mainLight) {
                mainLight.position.set(x * 50, y * 50, z * 50);
                updateWaterUniforms && updateWaterUniforms();
            }
        }

        const MAX_WAVES = 20; // æœ€å¤šåŒæ—¶å­˜åœ¨çš„æ³¢çº¹åœˆæ•°
        const waveCenters = Array(MAX_WAVES).fill().map(() => new THREE.Vector2(0, 0));
        const waveStartTimes = Array(MAX_WAVES).fill(-10);
        let lastClickTime = 0; // ä¸Šä¸€æ¬¡ç‚¹å‡»çš„æ—¶é—´æˆ³ï¼ˆç§’ï¼‰
        const CLICK_INTERVAL = 0.2; // å…è®¸çš„æœ€å°ç‚¹å‡»é—´éš”ï¼ˆç§’ï¼‰

        // é¼ æ ‡ç‚¹å‡»äº‹ä»¶ï¼Œç”Ÿæˆæ³¢çº¹
        // é™åˆ¶ï¼š1ç§’å†…åªå…è®¸ä¸€æ¬¡ç‚¹å‡»ç”Ÿæ•ˆï¼Œä¸”æœ€å¤šåªèƒ½æœ‰MAX_WAVESä¸ªæ³¢çº¹
        // æ–°æ³¢çº¹ä¼šå¤ç”¨å·²æ¶ˆå¤±çš„æ§½ä½ï¼Œæ‰€æœ‰æ³¢çº¹ç‹¬ç«‹æ‰©æ•£
        document.getElementById('canvas').addEventListener('pointerdown', function (e) {
            const now = performance.now() * 0.001;
            // 1. é™åˆ¶ç‚¹å‡»é—´éš”ï¼Œ1ç§’å†…åªå…è®¸ä¸€æ¬¡ç”Ÿæ•ˆ
            if (now - lastClickTime < CLICK_INTERVAL) return;
            lastClickTime = now;

            // 2. è®¡ç®—é¼ æ ‡åœ¨canvasä¸Šçš„å½’ä¸€åŒ–åæ ‡
            const rect = this.getBoundingClientRect();
            const x = ((e.clientX - rect.left) / rect.width) * 2 - 1;
            const y = -((e.clientY - rect.top) / rect.height) * 2 + 1;

            // 3. å°„çº¿æŠ•å°„ï¼Œè·å–æ°´é¢äº¤ç‚¹çš„uv
            const mouse = new THREE.Vector2(x, y);
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(waterMesh);
            if (intersects.length > 0) {
                const uv = intersects[0].uv;
                // 4. æŸ¥æ‰¾å¯ç”¨æ§½ä½ï¼ˆå·²æ¶ˆå¤±çš„æ³¢çº¹ï¼‰
                let slot = -1;
                for (let i = 0; i < MAX_WAVES; i++) {
                    if (now - waveStartTimes[i] > 1.5) { // 1.5ç§’åè§†ä¸ºæ³¢çº¹æ¶ˆå¤±
                        slot = i;
                        break;
                    }
                }
                // 5. å¦‚æœæ²¡æœ‰å¯ç”¨æ§½ä½ï¼Œåˆ™ä¸æ·»åŠ æ–°æ³¢çº¹ï¼ˆé™åˆ¶æœ€å¤§æ•°é‡ï¼‰
                if (slot === -1) return;
                // 6. å­˜å…¥æ³¢çº¹æ•°æ®
                waveCenters[slot].copy(uv);
                waveStartTimes[slot] = now;
                // 7. æ›´æ–°shader uniforms
                waterMesh.material.uniforms.waveCenters.value = waveCenters;
                waterMesh.material.uniforms.waveStartTimes.value = waveStartTimes;
                waterMesh.material.uniforms.waveCount.value = MAX_WAVES;
            }
        });

        // ========== è®¾ç½®é¢æ¿å±•å¼€/æŠ˜å åŠŸèƒ½ ==========
        // è·å–æŒ‰é’®å’Œé¢æ¿DOM
        const toggleBtn = document.getElementById('toggleSettingsPanel');
        const panel = document.getElementById('settingsPanel');
        const panelContent = document.getElementById('settingsPanelContent');
        // ç‚¹å‡»æŒ‰é’®åˆ‡æ¢ expanded class
        toggleBtn.addEventListener('click', function() {
            panel.classList.toggle('expanded');
        });
    </script>
</body>

</html>